[id='runtime-manager-strategies-con_{context}']
= Runtime manager strategies

The runtime manager supports the following strategies for managing KIE sessions.

*Singleton strategy*: instructs `RuntimeManager` to maintain a single instance of `RuntimeEngine` (and in turn single instance of `KieSession` and `TaskService`). Access to the runtime engine is synchronized and, therefore, thread safe, although it comes with a performance penalty due to synchronization.

ifdef::DROOLS,JBPM,OP[]
This strategy is similar to what was available by default in jBPM version 5.x. 
endif::DROOLS,JBPM,OP[]
Use this strategy for simple use cases.

It has the following characteristics that can be important for a usage scenario:

* It has a small memory footprint - single instance of the runtime engine and the task service.
* It is simple and compact in design and usage.
* It is a good fit for low to medium load on the {PROCESS_ENGINE} because of synchronized access.
* Because of the single KieSession instance, all state objects (such as facts) are directly visible to all process instances and vice versa.
* The strategy is not contextual. When you retrieve instances of RuntimeEngine from a singleton RuntimeManager, you do not need to take the `Context` instance into account. Usually, you can use EmptyContext.get() as the context, although a null argument is acceptable as well
* The runtime manager keeps track of the ID of the `KieSession`, so that the same session remains in use after a `RuntimeManager` restart. The ID is stored as a serialized file in a temporary location in the file system that, depending on the environment, can be one of the following directories:
** The value of the `jbpm.data.dir` system property
** The value of the `jboss.server.data.dir` system property
** The value of the `java.io.tmpdir` system property

[WARNING]
====
A combination of the Singleton strategy and the EJB Timer Scheduler has a limitation that it might raise Hibernate issues under load. The combination is not recommended for production use. The EJB Timer Scheduler is the default in the {KIE_SERVER}.
====

*Per request strategy*: instructs `RuntimeManager` to provide a new instance of `RuntimeEngine` for every request. One or more invocations of the {PROCESS_ENGINE} within a single transaction are considered a single request.

The same instance of `RuntimeEngine` must be used within single transaction to ensure correctness of state. Otherwise, an operation completed in one call would not be visible in the next call.

This stragegy is "stateless", as process state is preserved only within the request. When a request is completed, the `RuntimeEngine` is permanently destroyed. If persistence is used, information related tothe KIE session is removed from the persistence database as well.

The strategy has the following characteristics:

* It provides completely isolated {PROCESS_ENGINE} and task service operations for every request.
* It is completely stateless, storage of any facts happens only for the duration of the request.
* It is a good fit for high-load, stateless processes, where no facts or timers must be preserved between requests.
* The `KieSession` is only available during the lifetime of a request and is destroyed at the end of the request.
* The strategy is not contextual. When you retrieve instances of RuntimeEngine from a singleton RuntimeManager, you do not need to take the `Context` instance into account. Usually, you can use EmptyContext.get() as the context, although a null argument is acceptable as well

*Per process instance strategy*: instructs `RuntimeManager` to maintain a strict relationship between a KIE session and a process instance. Each `KieSession` is available as long as the `ProcessInstance` to which it belongs is active.

This strategy provides the most flexible approach to use advanced capabilities of the {PROCESS_ENGINE} like rule evaluation and isolation between process instances. It maximizes performance and reduces potential bottlenecks introduced by synchronization. At the same time, unlike the request strategy, it reduces the number of KIE sessions to the actual number of process instances, rather than the total number of requests.

This strategy has the following characteristics:

* It provides isolation for every process instance.
* It maintains a strict relationship between `KieSession` and `ProcessInstance` to ensure that it will always deliver the same `KieSession` for a given `ProcessInstance`.
* It merges the lifecycle of `KieSession` with `ProcessInstance`, and both are disposed when the process instance completes or aborts.
* It enables maintaining data, such facts and timers, in the scope of the process instance. Only the process instance has access to the data.
* It introduces some overhead because of the need to look up and load the `KieSession` for the process instance.
* It validates every usage of a `KieSession` so it cannot be used for other process instances. An exception is thrown if another process instance would use the same `KieSession`.
* The strategy is contextual and accepts the following context instances:

** `EmptyContext` or null: When starting a process instance, as there is no process instance id available yet
** `ProcessInstanceIdContext`: Used after process instance was created
** `CorrelationKeyContext`: Used as an alternative to `ProcessInstanceIdContext` to use a custom (business) key instead of the process instance id
