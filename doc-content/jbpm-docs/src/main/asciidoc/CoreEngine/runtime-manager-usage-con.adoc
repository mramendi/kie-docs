[id='runtime-manager-usage-con_{context}']
= Typical usage scenario for the runtime manager

The typical usage scenario for `RuntimeManager` consists of the following stages:

* At application startup time, complete the following stage:
** Build `RuntimeManager` and keep it for the entire lifetime of the application, as it is thread-safe and can be accessed concurrently

* At request time, complete the following stages:
** Get `RuntimeEngine` from `RuntimeManager`, using the proper context instance as determined by the strategy of the `RuntimeManager`
** Get the `KieSession` and `TaskService` objects from the `RuntimeEngine`
** Use the `KieSession` and `TaskService` objects for operations such as `startProcess`, `completeTask`, and so on
** After completing processingm dispose `RuntimeEngine` using the `RuntimeManager.disposeRuntimeEngine` method

* At application shutdown time, complete the following stage:
** close `RuntimeManager`

[NOTE]
====
When `RuntimeEngine` is obtained from `RuntimeManager` within an active JTA transaction, you do not need to dispose `RuntimeEngine` at the end, as `RuntimeManager` will automatically dispose the `RuntimeEngine` on transaction completion (regardless of the completion status: commit or rollback).
====

The following example shows how you can build `RuntimeManager` and get `RuntimeEngine` (that encapsulates `KieSession` and `TaskService`) from it:

[source,java,subs="attributes+"]
----

    // first configure the environment that will be used by RuntimeManager
    RuntimeEnvironment environment = RuntimeEnvironmentBuilder.Factory.get()
    .newDefaultInMemoryBuilder()
    .addAsset(ResourceFactory.newClassPathResource("BPMN2-ScriptTask.bpmn2"), ResourceType.BPMN2)
    .get();

    // next create the RuntimeManager - in this case the singleton strategy is chosen
    RuntimeManager manager = RuntimeManagerFactory.Factory.get().newSingletonRuntimeManager(environment);

    // then get RuntimeEngine from the runtime manager, using empty context because singleton does not keep track
    // of runtime engine as there is only one
    RuntimeEngine runtime = manager.getRuntimeEngine(EmptyContext.get());

    // get the KieSession from the runtimeEngine - already initialized with all handlers, listeners, and other requirements
    // configured on the environment
    KieSession ksession = runtimeEngine.getKieSession();

    // add invocations of the {PROCESS_ENGINE} here,
    // e.g. ksession.startProcess(processId);

    // finally, dispose the runtime engine
    manager.disposeRuntimeEngine(runtimeEngine);
----

This example provides the simplest, or minimal, way of using `RuntimeManager` and `RuntimeEngine`. It has the following characteristics:

* `KieSession` is in memory, using `newDefaultInMemoryBuilder`
* A single process, which is added as an asset, is available for execution
* `TaskService` is configured and attached to the `KieSession` via `LocalHTWorkItemHandler` to support user task capabilities within processes

